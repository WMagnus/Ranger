package com.wolfemagnus.ranger;

/**
 * RangerAES.java
 * Ranger
 *
 * Created by Wolfe Magnus on 6/3/2015.
 * Copyright (c) 2015 Donoho Design Group, LLC. All rights reserved.
 *
 */

/*
 This class performs round trip encryption and decryption of an arbitrarily
 sized in-memory block of data. It uses the AES symmetric encryption
 cipher and a random initialization vector (IV). Following Ferguson's and
 Schneier's advice, the random IV is pre-pended to the ciphertext. We use
 a random IV because the data encrypted with these methods is intended to be
 stored in a database and accessed in a random order. Hence, a counter
 formalism could not be effectively managed. Each encrypted datum contains
 everything needed but the key to decrypt it.
 The CBC, Cipher Block Chaining, mode pattern of use is described in:
     Niels Ferguson and Bruce Schneier. "Practical Cryptography",
     Wiley Publishing, Inc., Indianapolis, Indiana, 2003.
     [Section 5.3 CBC, Pages 70-71]
 The ciphertext structure is:

     struct {
         uint8_t iv[kCCBlockSizeAES128];
         uint8_t cipherText[];
     };

 The cipher text block consists of two concatenated runs of data. The first
 is the random IV of kCCBlockSizeAES128, 16, bytes generated by Oracle's
 SecureRandom class, which matches the requirements set in FIPS 140-2,
 Security Requirements for Cryptographic Modules. The second is an arbitrary
 number of bytes encrypted with the AES cipher and padded using PKCS7 padding.
 */

//Java has an inbuilt secure random number generator.
import java.nio.ByteBuffer;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;

import javax.crypto.*;



public class RangerAES {
    //Due to inability to find these or an equivalent in the API, size lengths
    final static int kCCKeySizeAES128 = 16;
    final static int kCCKeySizeAES192 = 24;
    final static int kCCKeySizeAES256 = 32;
    final static int kCCBlockSizeAES128 = 16;
    private static final String AES_ALGORITHM = "AES/CBC/PKCS5Padding";

    // The size of the private key determines the width of the AES encryption.
    // kCCKeySizeAES128, 128 bit key -> AES-128
    // kCCKeySizeAES192, 192 bit key -> AES-192
    // kCCKeySizeAES256, 256 bit key -> AES-256

    static void writeIV(byte contents[], int length) {

        assert(contents.length >= length) : "Must have enough space to add the IV";

        SecureRandom random = new SecureRandom();

        //TODO: Find a way to generate seeds with relatively high entropy

        //Creation of a temporary array to fit a perfectly sized IV.
        byte[] IVSpace = new byte[length];

        //Actually obtaining the random bytes.
        random.nextBytes(IVSpace);

        //Transfer over IVSpace to contents
        for(int i = 0; i < length; i++) contents[i] = IVSpace[i];


    } // writeIV(byte contents[]);

    static ByteBuffer encryptWithData(byte[] data, SecretKey key) throws InvalidKeyException,
                        NoSuchPaddingException, NoSuchAlgorithmException, ShortBufferException,
                        IllegalBlockSizeException, BadPaddingException{
        //Initial Assertions
        assert(data != null && data.length != 0) : "Must have data to encrypt.";
        assert(key.getEncoded().length == kCCKeySizeAES256 ||
                key.getEncoded().length == kCCKeySizeAES192 ||
                key.getEncoded().length == kCCKeySizeAES128)
                : "The key must exist and be either 128, 192 or 256 bits long.";

        int cipherLength = data.length + 2 * kCCBlockSizeAES128;
        byte[] cipherText = new byte[cipherLength];

        if (cipherText != null) {
            writeIV(cipherText, kCCBlockSizeAES128);

            int dataOutMoved = 0;

            Cipher aesCryptor = Cipher.getInstance(AES_ALGORITHM);
            aesCryptor.init(Cipher.ENCRYPT_MODE, key);

            int result = aesCryptor.doFinal(data, //INPUT
                    0,  //Input offset should be 0.
                    data.length,//Length of the encrypting data
                    cipherText,
                    kCCBlockSizeAES128); // Offset for the output (offset by IV length)

            if(result != kCCBlockSizeAES128) {
                ByteBuffer cipherData = ByteBuffer.wrap(cipherText);

                if(cipherData != null) {
                    return cipherData;
                }
            }
        }

        return null;
    } //static ByteBuffer encryptWithData(byte[] data, SecretKey key);

    static byte[] decryptWithData(byte[] ciphertext, SecretKey key) throws InvalidKeyException,
                        NoSuchPaddingException, NoSuchAlgorithmException, ShortBufferException,
                        IllegalBlockSizeException, BadPaddingException {
        //Initial Assertions
        assert(ciphertext != null && ciphertext.length != 0) : "Must have data to encrypt.";
        assert(key.getEncoded().length == kCCKeySizeAES256 ||
                key.getEncoded().length == kCCKeySizeAES192 ||
                key.getEncoded().length == kCCKeySizeAES128)
                : "The key must exist and be either 128, 192 or 256 bits long.";

        int textlength = ciphertext.length;
        byte[] plaintext = new byte[textlength];

        if(plaintext != null) {
            Cipher aesCryptor = Cipher.getInstance(AES_ALGORITHM);
            aesCryptor.init(Cipher.DECRYPT_MODE, key);

            int result = aesCryptor.doFinal(ciphertext, //INPUT
                    kCCBlockSizeAES128,  //Offset for the input (offset by IV length)
                    ciphertext.length,//Length of the decrypting data
                    plaintext,
                    0); //Offset for the plaintext (should be 0)

            if (result != kCCBlockSizeAES128) {
                if(plaintext != null){
                    return plaintext;
                }
            }
        }

        return null;
    } //static byte[] decryptWithData(byte[] ciphertext, SecretKey key

}
